# 05 | 数组：为什么很多编程语言中数组都从0开始编号？


## 一、什么是数组？
数组（Array）是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组具有**相同类型**的数据。

关键词：
- **线性表**：线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，**链表、队列、栈**等也是线性表结构。
  
  与它相对立的概念是**非线性表**，比如**二叉树、堆、图**等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

- **连续的内存空间和相同类型的数据**：正是因为这两个限制，使得数组拥有**随机访问**的特性。
  
  但这两个限制也让数组的很多操作变得非常低效，比如要想在数组中**删除、插入**一个数据，为了保证连续性，就需要做大量的数据搬移工作。


对于一个数组 int[] a = new int[10]，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要**随机访问**数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：

```c
a[i]_address = base_address + i * data_type_size
```

从数组存储的内存模型上来看，“**下标**”最确切的定义应该是“**偏移（offset）**”。如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用上面这个公式。

但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：
```c
a[k]_address = base_address + (k-1) * data_type_size
```

每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。

还有一个历史原因是，C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。


## 二、低效的“插入”和“删除”

### 1. 插入操作
假设数组的长度为 n，如果要将一个数据插入到第 k 个位置，需要将第 k～n 这部分的元素都顺序地往后挪一位。

在数组的末尾插入元素时间复杂度为 O(1)。若在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。平均情况时间复杂度为 (1+2+…n)/n=O(n)。

为了避免大规模的数据搬移，一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。这样时间复杂度就会降为 O(1) （但这样做会破坏数组的原有顺序）。

### 2. 删除操作

和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。

为了避免多个数据会被多次搬移，可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是**记录**数据已经被删除。当数组没有更多空间存储数据时，再触发**执行一次**真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

这就是 JVM 标记清除垃圾回收算法的核心思想。

## 三、警惕数组的访问越界问题

在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。

下面这段代码会造成死循环：

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

死循环的问题跟编译器分配内存和字节对齐有关，数组 3 个元素加上一个变量 a，4 个整数刚好能满足 8 字节对齐 所以 i 的地址恰好跟着 a[2] 后面,导致死循环。如果数组本身有 4 个元素 则这里不会出现死循环。因为编译器64位操作系统下 默认会进行 8 字节对齐,变量 i 的地址就不紧跟着数组后面了。


## 四、容器能否完全替代数组

相比于数字，java 中的 ArrayList 封装了数组的很多操作，并支持动态扩容。一旦超过存储容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。
数组适合的场景：
1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类。而且装箱拆箱 （Autoboxing、Unboxing），有一定的性能损耗，如果特别关注性能，可以考虑数组；
2. 若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组；
3. 表示多维数组时，数组往往更加直观；

业务开发使用容器即可，而底层开发，如网络框架，需要极致的性能优化则选择数组。

